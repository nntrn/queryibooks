#!/usr/bin/env bash
# shellcheck disable=SC2034,SC1090
# Author: https://github.com/nntrn
# Repository: https://github.com/nntrn/queryibooks

set -e

PROG=queryibooks
VERSION=2.1
TODAY="$(date +%F-%H)"

IBOOKS_LIBRARY=$HOME/Library/Containers/com.apple.iBooksX
QUERYIBOOKS_HOME="$HOME/.cache/queryibooks"
QUERYIBOOKS_CACHE="$QUERYIBOOKS_HOME/$TODAY"

mkdir -p $QUERYIBOOKS_CACHE

declare -A db_annotations
db_annotations[name]=annotations
db_annotations[path]="$(ls -1 $IBOOKS_LIBRARY/Data/Documents/AEAnnotation/*.sqlite)"
db_annotations[sql]="select * from ZAEANNOTATION
where ZANNOTATIONSELECTEDTEXT IS NOT NULL
and ZANNOTATIONSELECTEDTEXT <> ''
and ZANNOTATIONDELETED = 0;"

declare -A db_assets
db_assets[name]=assets
db_assets[path]="$(ls -1 $IBOOKS_LIBRARY/Data/Documents/BKLibrary/*.sqlite)"
db_assets[sql]="select * from ZBKLIBRARYASSET;"

HELP_TEXT='
queryibooks - Tool for extracting iBooks annotations

USAGE:
  queryibooks [-f|--no-cache] [-w|--write-to]
  queryibooks [-h|--help] [-v|--version]

OPTIONS:
  -f, --no-cache          Run database update regardless of data changes
  -w, --write-to          Where to write output to
  -h, --help
  -v, --version

ENVIRONMENT:
  export QUERYIBOOKS_NO_CACHE=<BooleanInt>
  export QUERYIBOOKS_OUTPUT=<FILEPATH>
'

JQ_FUNC='
  def map_annotations: {
    Z_PK,
    ZANNOTATIONCREATIONDATE,
    ZANNOTATIONASSETID,
    ZFUTUREPROOFING5,
    ZANNOTATIONNOTE,
    ZANNOTATIONSTYLE,
    ZANNOTATIONTYPE,
    ZANNOTATIONISUNDERLINE,
    ZPLLOCATIONRANGESTART,
    ZANNOTATIONLOCATION,
    ZANNOTATIONSELECTEDTEXT,
    ZANNOTATIONREPRESENTATIVETEXT
  };

  def map_assets: {
    ZASSETID,
    ZTITLE,
    ZAUTHOR,
    ZGENRE,
    ZSTOREID,
    ZSORTAUTHOR,
    ZSORTTITLE,
    ZASSETGUID
  };

  def map_json:
    reduce inputs as $s (.; .[input_filename|gsub(".json";"")|split("/")|last|ascii_downcase] += $s);

  def join_assets:
    INDEX(
      .assets[]; .ZASSETID) as $c
      | .annotations
      | map((map_annotations)+($c[.ZANNOTATIONASSETID]|map_assets)
    );

  def convertmacostime:
    map(
      with_entries( .key as $k|.value |= (
        if ($k|contains("DATE"))
        then ((.// 0) +978307200|strflocaltime("%FT%TZ"))
        else .
        end
        )
      )
    );

  def build: map_json|join_assets|convertmacostime;
'

_usage() {
  echo "$HELP_TEXT"
  exit 1
}

_version() {
  echo "$PROG-$VERSION"
  exit 0
}

_log() {
  echo -e "\e[0;49;36m$* \e[0m" 3>&2 2>&1 >&3 3>&-
}

sync_database() {
  local DB="$1"
  if [[ -f $DB-wal ]]; then
    MOD_DB=$(date -r "$DB" +%s)
    MOD_WALDB=$(date -r "${DB}-wal" +%s)
    if [[ $MOD_DB -lt $MOD_WALDB ]]; then
      _log "Syncing ${DB##*/} (Last sync: $(date -r $DB +'%F %X'))"
      sqlite3 "$DB" 'pragma wal_checkpoint;' ".exit" >/dev/null
      return $?
    fi
  fi
}

querydata() {
  local -n data=$1
  TABLE="${data[name]}"
  DB_PATH="${data[path]}"
  SQL="${data[sql]}"
  SAVEFILE="${QUERYIBOOKS_CACHE}/${TABLE}.json"

  sync_database "$DB_PATH"

  if [[ ! -f $SAVEFILE ]] || [[ $QUERYIBOOKS_NO_CACHE -eq 1 ]]; then
    _log "Saving $TABLE to $SAVEFILE"
    sqlite3 -json "$DB_PATH" "$SQL" ".exit" >$SAVEFILE
  else
    _log "Reading $TABLE from $SAVEFILE"
  fi
}

for i in "$@"; do
  case $i in
  -h | --help) _usage ;;
  -v | --version) _version ;;
  -f | --no-cache) QUERYIBOOKS_NO_CACHE=1 && shift ;;
  -w | --write-to) QUERYIBOOKS_OUTPUT=$2 && shift 2 ;;
  esac
done

if ! command -v jq &>/dev/null; then
  echo "Download jq before continuing.. Aborting"
  exit 1
fi

querydata db_assets
querydata db_annotations

jq -n "$JQ_FUNC build" ${QUERYIBOOKS_CACHE}/{assets,annotations}.json >$QUERYIBOOKS_CACHE/ibooks.json

if [[ -n $QUERYIBOOKS_OUTPUT ]]; then
  cp "$QUERYIBOOKS_CACHE/ibooks.json" "$QUERYIBOOKS_OUTPUT"
  _log "Saved to $QUERYIBOOKS_OUTPUT"
else
  cat $QUERYIBOOKS_CACHE/ibooks.json
fi
